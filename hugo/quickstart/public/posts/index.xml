<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on BoomChao Site&#39;</title>
    <link>https://BoomChao.github.io/posts/</link>
    <description>Recent content in Posts on BoomChao Site&#39;</description>
    <image>
      <title>BoomChao Site&#39;</title>
      <url>https://BoomChao.github.io/images/papermod-cover.png</url>
      <link>https://BoomChao.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.138.0</generator>
    <language>en</language>
    <lastBuildDate>Sat, 30 Nov 2024 20:43:12 +0800</lastBuildDate>
    <atom:link href="https://BoomChao.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 周赛 424</title>
      <link>https://BoomChao.github.io/posts/weekly-424/</link>
      <pubDate>Sat, 30 Nov 2024 20:43:12 +0800</pubDate>
      <guid>https://BoomChao.github.io/posts/weekly-424/</guid>
      <description>&lt;h3 id=&#34;第一题-make-array-elements-equal-to-zerohttpsleetcodecomproblemsmake-array-elements-equal-to-zero&#34;&gt;第一题: &lt;a href=&#34;https://leetcode.com/problems/make-array-elements-equal-to-zero/&#34;&gt;Make Array Elements Equal to Zero&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;解析：
首先如果这个数组是一个有效的数组，那么肯定0元素左边的所有元素的和和0元素右边所有元素的和的绝对差&amp;lt;=1
比如，下面这个有效数组&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[1,0,2,0,3]
index = 3
leftSum = 3, rightSum = 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以是有效数组,而下面这个数组&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[2,3,4,0,4,1,0]
无论选中哪个0元素，左右两边的和均不相等，所以肯定不是有效数组
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;答案如下：时间复杂度 O(n)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int countValidSelections(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    std::vector&amp;lt;int&amp;gt; ps(nums.size() + 1);
    // 高级写法：计算向量和
    partial_sum(nums.begin(), nums.end(), ps.begin() + 1);      // 后撤一位,这样i元素之前所有的元素和就是ps[i]
    int res = 0;
    for(int i = 0; i &amp;lt; nums.size(); i++) {
        if(nums[i] == 0) {
            if(ps.back() == 2 * ps[i]) res += 2;                // 相等则左右两个方向移动均可
            else if(abs(ps.back() - 2 * ps[i]) == 1) res += 1;  // 相差一则只能一个方向移动
        }
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;第二题-zero-array-transformation-ihttpsleetcodecomproblemszero-array-transformation-idescription&#34;&gt;第二题: &lt;a href=&#34;https://leetcode.com/problems/zero-array-transformation-i/description/&#34;&gt;Zero Array Transformation I&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;解析：
反向思考，只要记录下 queries 区间内的元素间隔，叠加这个间隔之间的元素的值，判断是否大于原始数组即可
比如&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
